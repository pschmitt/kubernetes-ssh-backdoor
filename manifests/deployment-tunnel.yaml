apiVersion: apps/v1
kind: Deployment
metadata:
  name: tunnel
  namespace: ssh-tunnel
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: tunnel
  template:
    metadata:
      labels:
        app: tunnel
    spec:
      terminationGracePeriodSeconds: 5
      serviceAccountName: breakglass-admin
      initContainers:
      - name: publish
        image: pschmitt/debug:latest
        command:
        - /bin/sh
        args:
        - -c
        - |
          set -eu
          if [ "${DEBUG:-false}" = "true" ]
          then
            set -x
          fi

          # Setup SSH
          mkdir -p /root/.ssh
          cp /keys/id_ed25519 /root/.ssh/id_ed25519
          chmod 600 /root/.ssh/id_ed25519

          # Write known_hosts from ConfigMap env var
          echo "$SSH_KNOWN_HOSTS" > /root/.ssh/known_hosts
          chmod 644 /root/.ssh/known_hosts

          # Auto-detect cluster name if not provided
          if [ -z "${CLUSTER_NAME}" ] || [ "${CLUSTER_NAME}" = "" ]
          then
            # Try cluster-info ConfigMap first
            CLUSTER_NAME=$(kubectl get configmap -n kube-system cluster-info -o jsonpath='{.data.name}' 2>/dev/null || true)

            if [ -z "${CLUSTER_NAME}" ]
            then
              # Fallback to generating from namespace and timestamp
              CLUSTER_NAME="${NAMESPACE}-$(date +%s)"
              echo "Generated cluster name: ${CLUSTER_NAME}"
            else
              echo "Detected cluster name: ${CLUSTER_NAME}"
            fi
          fi

          # Set kubeconfig name based on cluster name if not already set
          if [ -z "${BASTION_KUBECONFIG_NAME}" ] || [ "${BASTION_KUBECONFIG_NAME}" = "" ]
          then
            BASTION_KUBECONFIG_NAME="config-${CLUSTER_NAME}"
          fi

          TOKEN="$(kubectl -n "${NAMESPACE}" create token breakglass-admin --duration 87600h)"
          CA_B64="$(base64 -w0 /var/run/secrets/kubernetes.io/serviceaccount/ca.crt)"

          tmp=/tmp/kubeconfig.yaml
          cat > "$tmp" <<EOF
          apiVersion: v1
          kind: Config
          clusters:
          - name: ${CLUSTER_NAME}
            cluster:
              certificate-authority-data: ${CA_B64}
              server: https://127.0.0.1:${REMOTE_PORT}
              tls-server-name: kubernetes.default.svc
          users:
          - name: breakglass-admin-${CLUSTER_NAME}
            user:
              token: ${TOKEN}
          contexts:
          - name: ${CLUSTER_NAME}-tunnel
            context:
              cluster: ${CLUSTER_NAME}
              user: breakglass-admin-${CLUSTER_NAME}
          current-context: ${CLUSTER_NAME}-tunnel
          EOF

          # Create directories on bastion and resolve the full path
          ssh -o ControlMaster=no \
              -o ControlPath=none \
              -o StrictHostKeyChecking=yes \
              -o UserKnownHostsFile=/root/.ssh/known_hosts \
              -i /root/.ssh/id_ed25519 \
              -p "${BASTION_PORT}" \
              "${BASTION_USER}@${BASTION_HOST}" \
              "mkdir -p ${BASTION_KUBECONFIG_DIR} ~/bin"

          # Resolve the full path on the remote host
          RESOLVED_KUBECONFIG_DIR=$(ssh -o ControlMaster=no \
              -o ControlPath=none \
              -o StrictHostKeyChecking=yes \
              -o UserKnownHostsFile=/root/.ssh/known_hosts \
              -i /root/.ssh/id_ed25519 \
              -p "${BASTION_PORT}" \
              "${BASTION_USER}@${BASTION_HOST}" \
              "readlink -f ${BASTION_KUBECONFIG_DIR}")

          RESOLVED_KUBECONFIG_PATH="${RESOLVED_KUBECONFIG_DIR}/${BASTION_KUBECONFIG_NAME}"
          echo "Resolved kubeconfig path on bastion: ${RESOLVED_KUBECONFIG_PATH}"

          # Create kubectl wrapper script with resolved path
          wrapper="/tmp/kubectl-${CLUSTER_NAME}"
          cat > "$wrapper" <<WRAPPER_EOF
          #!/usr/bin/env bash
          exec kubectl --kubeconfig="${RESOLVED_KUBECONFIG_PATH}" "\$@"
          WRAPPER_EOF

          chmod +x "$wrapper"

          # Upload kubeconfig
          scp -o ControlMaster=no \
              -o ControlPath=none \
              -o StrictHostKeyChecking=yes \
              -o UserKnownHostsFile=/root/.ssh/known_hosts \
              -i /root/.ssh/id_ed25519 \
              -P "${BASTION_PORT}" \
              "$tmp" "${BASTION_USER}@${BASTION_HOST}:${BASTION_KUBECONFIG_DIR}/.${BASTION_KUBECONFIG_NAME}.tmp"

          # Upload kubectl wrapper
          scp -o ControlMaster=no \
              -o ControlPath=none \
              -o StrictHostKeyChecking=yes \
              -o UserKnownHostsFile=/root/.ssh/known_hosts \
              -i /root/.ssh/id_ed25519 \
              -P "${BASTION_PORT}" \
              "$wrapper" "${BASTION_USER}@${BASTION_HOST}:~/bin/kubectl-${CLUSTER_NAME}"

          # Atomically move kubeconfig into place
          ssh -o ControlMaster=no \
              -o ControlPath=none \
              -o StrictHostKeyChecking=yes \
              -o UserKnownHostsFile=/root/.ssh/known_hosts \
              -i /root/.ssh/id_ed25519 \
              -p "${BASTION_PORT}" \
              "${BASTION_USER}@${BASTION_HOST}" \
              "mv ${BASTION_KUBECONFIG_DIR}/.${BASTION_KUBECONFIG_NAME}.tmp ${BASTION_KUBECONFIG_DIR}/${BASTION_KUBECONFIG_NAME} && chmod +x ~/bin/kubectl-${CLUSTER_NAME}"

          echo "Kubeconfig and kubectl wrapper published successfully"
          echo "Use: kubectl-${CLUSTER_NAME} get nodes"
        env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        envFrom:
        - configMapRef:
            name: tunnel-config
        volumeMounts:
        - name: ssh-private-key
          mountPath: /keys
          readOnly: true

      containers:
      - name: tunnel
        image: pschmitt/ssh:latest
        command:
        - /bin/sh
        args:
        - -c
        - |
          set -eu
          if [ "${DEBUG:-false}" = "true" ]
          then
            set -x
          fi

          # Setup SSH directory and keys
          mkdir -p /config/.ssh
          cp /keys/id_ed25519 /config/.ssh/id_ed25519
          chmod 600 /config/.ssh/id_ed25519

          # Write known_hosts from ConfigMap env var
          echo "$known_hosts" > /config/.ssh/known_hosts
          chmod 644 /config/.ssh/known_hosts

          # SSH tunnel loop with automatic reconnection
          while true
          do
            echo "Starting SSH tunnel to ${BASTION_HOST}:${BASTION_PORT}..."
            ssh \
              -N \
              -o ControlMaster=no \
              -o ControlPath=none \
              -o ServerAliveInterval=10 \
              -o ServerAliveCountMax=3 \
              -o StrictHostKeyChecking=yes \
              -o UserKnownHostsFile=/config/.ssh/known_hosts \
              -o ExitOnForwardFailure=yes \
              -i /config/.ssh/id_ed25519 \
              -p "${BASTION_PORT}" \
              -R "127.0.0.1:${REMOTE_PORT}:kubernetes.default.svc:443" \
              "${BASTION_USER}@${BASTION_HOST}"

            EXIT_CODE=$?
            echo "SSH tunnel disconnected with exit code ${EXIT_CODE}"

            # Wait before reconnecting
            echo "Waiting 5 seconds before reconnecting..."
            sleep 5
          done
        lifecycle:
          preStop:
            exec:
              command:
              - /bin/sh
              - -c
              - |
                # Kill all SSH processes to terminate cleanly
                killall ssh || true
        envFrom:
        - configMapRef:
            name: tunnel-config
        volumeMounts:
        - name: ssh-private-key
          mountPath: /keys
          readOnly: true

      volumes:
      - name: ssh-private-key
        secret:
          secretName: ssh-private-key
          defaultMode: 0444
